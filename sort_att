function [newObjTag,objTagNum,dividTag,dividTagNum,dot,dotI] = sort_att(S,attInd,objTag,objTagNum,dividTag,dividTagNum)
%使用排序算法按照指定列上的元素是否相等进行排序，这样相等的就放在一起方便进行后续的一致性判断

%输入为：S1=(Y,C1,D1,f),所选条件属性的索引attInd,对象序列化objTag[],剩余对象数量objTagNum
%对象序列化的分区dividTag[][2],分区号dividTagNum，同时也是分区数量
%dividTag[i][1]是第i个分区的起始元素下标，dividTag[i][2]是第i个分区的终止元素下标
%输出为：新对象序列化newObjTag[]，也就是排序后的下标队列
dot(:) = zeros(1,objTagNum);
dotI(:) = zeros(1,objTagNum);
[ss,newObjTag] = sortrows(S,attInd);
for i=1:objTagNum
    if i == objTagNum
        dividTag(dividTagNum,2) = i;
        dot(dividTagNum) = i;%保存重新排序之后每个分组最后一个元素在未分组前的下标
        dotI(dividTagNum) = ss(i,attInd);%保存重新排序后每个分组属性值
        break;
    end
    if ss(i,attInd) ~= ss(i+1,attInd)
        dividTag(dividTagNum,2) = i;
        dot(dividTagNum) = i;%保存重新排序之后每个分组
        dotI(dividTagNum) = ss(i,attInd);%保存重新排序后每个分组属性值
        dividTagNum = dividTagNum+1;
        dividTag(dividTagNum,1) = i+1;
    end
end
%输出newObjTag

end

