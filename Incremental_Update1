function [didata,sort,org,sigNip,dividTagNum] = Incremental_Update1(j,num,S,didata,sort,org,data,sigNip,dividTagNum,length)
%UNTITLED 此处显示有关此函数的摘要
%j是依照排序的属性
%num是新增对象的下标
%S是原来经过归一化以及对象约简之后的对象表
%didata是每个分组的属性值
%sort是每组最后一个对象的排序后下标
%org是原下标
%data是等于z_traindata(i+n,:)的，表示需要对比添加进表中的对象
%sigNip是m个属性的重要度
%dividTagNum是之前分组的数量
%   此处显示详细说明
i = 1;
flag = 0;%用来判断是不是已经处理过了
while i<=dividTagNum
    if data(j) == didata(i)%第i个分组的属性值与新增对象的相等
        if i==1
            for k=sort(i):sort(i+1)-1%对比与该分组内其他对象有没有完全相同的
                for m = 1:size(data,2)
                    if m~=j&&data(m)~=S(org(k),m)%说明不相同
                        break;
                    end
                    if m==size(data,2)%到最后一个属性都没有break，是相同的
                        flag = 1;
                        for p = i+1:dividTagNum
                            sort(p)=sort(p)+1;
                        end
                        clear p
                        p = size(org,2)-1;
                        while p>k
                            org(p+1) = org(p);
                            p=p-1;
                        end
                        org(p) = num;
                        if k == sort(i)%说明是分组的最后一个对象相同，要更新
                            sort(i) = p;
                        end
                        clear p;
                    end
                end%m=1:size
                clear m;
                if flag == 1 %说明有相同的 已经处理过了
                    break;
                end
                if k==sort(i)&&flag==0 %说明没有和他完全相同的
                    if data(8)~=S(org(k),8)%决策属性不相等，重要度发生改变
                        for m=1:size(data,2)-1
                            if m~=j&&data(m)~=S(org(k),m) %属性重要度增加
                                sigNip(m) = sigNip(m)+1;
                            end
                            if m == size(data,2)-1 %所有属性都进行了对比
                                p = size(org,2)-1;
                                while p>k
                                    org(p+1) = org(p);
                                    p=p-1;
                                end
                                org(p+1) = num;
                                sort(i) = p+1;
                                if i~=dividTagNum
                                    for p = i+1:dividTagNum
                                        sort(p)=sort(p)+1;
                                    end
                                end
                                clear p;
                            end% if m=size-1
                        end% for m=1:size-1
                    else%D相等，直接插入到最后
                        p = size(org,2)-1;
                        while p>k
                            org(p+1) = org(p);
                            p=p-1;
                        end
                        org(p) = num;
                        sort(i) = p;
                        if i~=dividTagNum
                            for p = i+1:dividTagNum
                                sort(p)=sort(p)+1;
                            end
                        end
                        clear p;
                    end%ifD不相等
                end%没有完全相同的
                flag = 2;%说明没有完全相同，并且已经处理过了
                break;
            end%对比有没有相同的
        else
            for k=sort(i-1)+1:sort(i)%对比与该分组内其他对象有没有完全相同的
                for m = 1:size(data,2)
                    if m~=j&&data(m)~=S(org(k),m)%说明不相同
                        break;
                    end
                    if m==size(data,2)%到最后一个属性都没有break，是相同的
                        flag = 1;
                        for p = i+1:dividTagNum
                            sort(p)=sort(p)+1;
                        end
                        clear p
                        p = size(org,2)-1;
                        while p>k
                            org(p+1) = org(p);
                            p=p-1;
                        end
                        org(p) = num;
                        if k == sort(i)%说明是分组的最后一个对象相同，要更新
                            sort(i) = p;
                        end
                        clear p;
                    end
                end%m=1:size
                clear m;
                if flag == 1 %说明有相同的 已经处理过了
                    break;
                end
                if k==sort(i)&&flag==0 %说明没有和他完全相同的
                    if data(8)~=S(org(k),8)%决策属性不相等，重要度发生改变
                        for m=1:size(data,2)-1
                            if m~=j&&data(m)~=S(org(k),m) %属性重要度增加
                                sigNip(m) = sigNip(m)+1;
                            end
                            if m == size(data,2)-1 %所有属性都进行了对比
                               p = size(org,2)-1;
                                while p>k
                                    org(p+1) = org(p);
                                    p=p-1;
                                end
                                org(p+1) = num;
                                sort(i) = p+1;
                                if i~=dividTagNum
                                    for p = i+1:dividTagNum
                                        sort(p)=sort(p)+1;
                                    end
                                end
                                clear p;
                            end% if m=size-1
                        end% for m=1:size-1
                    else%D相等，直接插入到最后
                        p = size(org,2)-1;
                        while p>k
                            org(p+1) = org(p);
                            p=p-1;
                        end
                        org(p) = num;
                        sort(i) = p;
                        if i~=dividTagNum
                            for p = i+1:dividTagNum
                                sort(p)=sort(p)+1;
                            end
                        end
                        clear p;
                    end%ifD不相等
                flag = 2;%说明没有完全相同，并且已经处理过了
                end%没有完全相同的
            end%对比有没有相同的
        end
        if flag == 2
            break;
        end
    end
    if i==dividTagNum&&flag == 0%说明没有属性值相等的，作为新的分组加载最后面
        dividTagNum = dividTagNum+1;
        org(size(org,2)) = num;
        sort(dividTagNum) = size(org,2);
        didata(dividTagNum) = data(j);
        break;
    end
    i = i+1;
end
end
